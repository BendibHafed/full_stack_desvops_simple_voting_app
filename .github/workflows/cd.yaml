name: CD - controlled Deployment

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      approve_deployment:
        description: 'Approve and continue deployment?'
        required: true
        default: 'yes'
env:
  ACT: false

permissions:
  contents: read # To checkout the code
  packages: read # To pull Docker images from GHCR

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Debug ACT Mode
        run: |
          if [ "$ACT" = "true" ]; then
            echo " ACT mode detected — running locally"
          else
            echo " GitHub Actions mode — deploying remotely"
          fi

      - name: Install Docker Compose (ACT only)
        if: ${{ env.ACT == 'true' }}
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.5/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Install AWS CLI (ACT only)
        if: ${{ env.ACT == 'true' }}
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          sudo ./aws/install
          aws --version

      - name: Simulate App Locally with Docker Compose
        if: ${{ env.ACT == 'true' }}
        run: |
          docker-compose -f docker-compose.yaml up -d
          echo "Waiting for the App to be ready..."
          for i in {1..20}; do
            if curl -fs http://localhost:5000/healthz; then
              echo "App is healthy!"
              break
            fi
            sleep 3
          done
          docker-compose down

      - name: Start LocalStack (ACT only)
        if: ${{ env.ACT == 'true' }}
        env:
          AWS_ACCESS_KEY_ID: test
          AWS_SECRET_ACCESS_KEY: test
          AWS_DEFAULT_REGION: us-east-1
        run: |
          if docker ps -a --format '{{.Names}}' | grep -q '^localstack$'; then
            echo "Removing existing LocalStack container..."
            docker rm -f localstack || true
          fi

          echo "Starting LocalStack..."
          docker run -d --name localstack -p 4566:4566 -p 4571:4571 localstack/localstack
          sleep 10

          echo "Creating S3 bucket in LocalStack..."
          aws --endpoint-url=http://localhost:4566 s3 mb s3://my-local-bucket

      # (Optional but Recommended, Crucial for private repos) Login to GHCR
      - name: Log in to GitHub Container Registry
        if: ${{ github.event_name == 'workflow_dispatch' && env.ACT != 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure AWS credentials
        if: ${{ !env.ACT }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Test AWS credentials
        if: ${{ env.ACT != 'true' }}
        run: aws sts get-caller-identity

      - name: Ensure Terraform Backend Exists
        if: ${{ env.ACT != 'true' }}
        run: |
          set -e
          BUCKET="my-terraform-state-bucket-he1"
          REGION=${{ secrets.AWS_REGION }}
          DYNAMO_TABLE="terraform-locks"

          echo "Checking S3 bucket: $BUCKET"
          if ! aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
          echo "Creating S3 Bucket!"
            aws s3api create-bucket \
              --bucket "$BUCKET" \
              --region "$REGION" \
              --create-bucket-configuration LocationConstraint="$REGION"
            aws s3api put-bucket-encryption \
              --bucket "$BUCKET" \
              --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}' || true
          fi

          echo "Checking DynamoDB table: $DYNAMO_TABLE"
          if ! aws dynamodb describe-table --table-name "$DYNAMO_TABLE" >/dev/null 2>&1; then
            echo "Creating DynamoDB lock table..."
            aws dynamodb create-table \
              --table-name "$DYNAMO_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region "$REGION"
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.13.0"

      # Terraform Init (LocalStack)
      - name: Terraform Init (Local State)
        if: ${{ env.ACT }}
        working-directory: infra/terraform
        run: |
          rm -rf .terraform .terraform.lock.hcl backend_override.tf
          cat > backend_override.tf <<EOF
          terraform {
            backend "local" {
              path = "terraform.tfstate"
            }
          }
          EOF
          terraform init -reconfigure -input=false -no-color

      # Terraform Init (AWS real S3 backend)
      - name: Terraform Init (AWS)
        if: ${{ !env.ACT }}
        working-directory: infra/terraform
        run: terraform init -reconfigure -input=false

      - name: Terraform plan
        if: ${{ !env.ACT }}
        working-directory: infra/terraform
        run: |
          terraform plan -input=false -no-color -out=tfplan \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}"

      - name: Apply Terraform Changes
        working-directory: infra/terraform
        if: ${{ github.event_name == 'workflow_dispatch' && env.ACT != 'true' }}
        run: |
          terraform apply -input=false -auto-approve -no-color \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}" tfplan 
      
      - name: Get Terraform Outputs
        id: tf_outputs
        if: ${{ github.event_name == 'workflow_dispatch' && env.ACT != 'true' }}
        working-directory: infra/terraform
        run: |
          echo "EC2_IP=$(terraform output -raw ec2_public_ip)" >> $GITHUB_ENV
          echo "RDS_ENDPOINT=$(terraform output -raw rds_endpoint)" >> $GITHUB_ENV
          echo "RDS_PORT=$(terraform output -raw rds_port)" >> $GITHUB_ENV
          echo "APP_URL=$(terraform output -raw app_url)" >> $GITHUB_ENV

      - name: Configure SSH Private Key
        if: ${{ github.event_name == 'workflow_dispatch' && env.ACT != 'true' }}
        run: |
          mkdir -p infra/ansible/
          echo -e "${{ secrets.ANSIBLE_PRIVATE_KEY }}" > infra/ansible/ssh_private_key.pem
          chmod 600 infra/ansible/ssh_private_key.pem

      - name: Install Ansible and plugins
        if: ${{ github.event_name == 'workflow_dispatch' && env.ACT != 'true' }}
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible python3-boto3 python3-botocore

      - name: Create Ansible Inventory File
        working-directory: infra/ansible
        if: ${{ github.event_name == 'workflow_dispatch' && env.ACT != 'true' }}
        run: |
          echo "[voting]" > inventory.ini
          echo "$EC2_IP ansible_user=ubuntu ansible_ssh_private_key_file=ssh_private_key.pem" >> inventory.ini

      - name: Wait for EC2 to be ready
        if: ${{ github.event_name == 'workflow_dispatch' && env.ACT != 'true' }}
        run: |
          for i in {1..30}; do
            nc -zv ${{ env.EC2_IP }} 22 && break
            echo "Waiting for SSH port..."
            sleep 5
          done

      - name: Test SSH Connection
        working-directory: infra/ansible
        if: ${{ github.event_name == 'workflow_dispatch' && env.ACT != 'true' }}
        run: |
          echo "Testing connection to ${{ env.EC2_IP }}..."
          ssh -i ssh_private_key.pem \
              -o StrictHostKeyChecking=no \
              -o ConnectTimeout=10 \
              -o BatchMode=yes \
              ubuntu@${{ env.EC2_IP }} \
              "echo ' SSH connection successful'"

      - name: Deploy Application with Ansible Playbook
        working-directory: infra/ansible
        env:
          ANSIBLE_HOST_KEY_CHECKING: "False"
        if: ${{ github.event_name == 'workflow_dispatch' && env.ACT != 'true' }}
        run: |
          repo_slug=${GITHUB_REPOSITORY,,}
          ansible-playbook -i inventory.ini playbook.yaml \
            --private-key ssh_private_key.pem \
            --extra-vars "github_repo=${repo_slug} \
                          db_user=${{ secrets.DB_USERNAME }} \
                          db_pass=${{ secrets.DB_PASSWORD }} \
                          db_name=${{ secrets.DB_NAME }} \
                          rds_endpoint=${{ env.RDS_ENDPOINT }} \
                          rds_port=${{ env.RDS_PORT }} \
                          seed_db=true"

      - name: Run Smoke Test
        working-directory: infra/terraform
        if: ${{ github.event_name == 'workflow_dispatch' && env.ACT != 'true' }}
        run: |
          APP_URL=$(terraform output -raw app_url)
          echo "Testing app at $APP_URL"
          for i in {1..20}; do
            if curl -fs "$APP_URL/healthz"; then
              echo "App is healthy!"
              exit 0
            fi
            echo "Waiting for app..."
            sleep 5
          done
          echo "App failed health check"
          exit 1
